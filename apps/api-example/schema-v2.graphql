# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Consent {
  createdAt: DateTime!
  defaultValue: Boolean!
  id: String!
  modifiedAt: DateTime!
  name: String!
  slug: String!
}

input ConsentFilter {
  defaultValue: Boolean
  name: String
  slug: String
}

input ConsentInput {
  defaultValue: Boolean!
  name: String!
  slug: String!
}

type DashboardInvoice {
  amount: Int!
  dueAt: DateTime!
  memberPlan: String
  paidAt: DateTime
}

type DashboardSubscription {
  deactivationDate: DateTime
  endsAt: DateTime
  memberPlan: String!
  monthlyAmount: Int!
  paymentPeriodicity: PaymentPeriodicity!
  reasonForDeactivation: SubscriptionDeactivationReason
  renewsAt: DateTime
  startsAt: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type MailProviderModel {
  name: String!
}

type MailTemplateRef {
  id: String!
  name: String!
}

type MailTemplateWithUrlAndStatusModel {
  description: String
  externalMailTemplateId: String!
  id: String!
  name: String!
  remoteMissing: Boolean!
  status: String!
  url: String!
}

type MemberPlanRef {
  id: String!
  name: String!
}

type Mutation {
  """
  
        Create a new consent.
      
  """
  createConsent(consent: ConsentInput!): Consent!
  createSubscriptionFlow(subscriptionFlow: SubscriptionFlowModelCreateInput!): [SubscriptionFlowModel!]!
  createSubscriptionInterval(subscriptionInterval: SubscriptionIntervalCreateInput!): [SubscriptionFlowModel!]!

  """
  
        Creates a new userConsent based on input.
        Returns created userConsent.
      
  """
  createUserConsent(userConsent: UserConsentInput!): UserConsent!

  """
  
        Deletes an existing consent.
      
  """
  deleteConsent(id: String!): Consent!
  deleteSubscriptionFlow(subscriptionFlowId: String!): [SubscriptionFlowModel!]!
  deleteSubscriptionInterval(subscriptionInterval: SubscriptionIntervalDeleteInput!): [SubscriptionFlowModel!]!

  """
  
        Delete an existing userConsent by id.
        Returns deleted userConsent.
      
  """
  deleteUserConsent(id: String!): UserConsent!
  syncTemplates: Boolean
  testSystemMail(systemMail: SystemMailTestInput!): [SystemMailModel!]!

  """
  
        Updates an existing consent.
      
  """
  updateConsent(consent: ConsentInput!, id: String!): Consent!
  updateSubscriptionFlow(subscriptionFlow: SubscriptionFlowModelUpdateInput!): [SubscriptionFlowModel!]!
  updateSubscriptionInterval(subscriptionInterval: SubscriptionIntervalUpdateInput!): [SubscriptionFlowModel!]!
  updateSubscriptionIntervals(subscriptionIntervals: [SubscriptionIntervalUpdateInput!]!): [SubscriptionFlowModel!]!
  updateSystemMail(systemMail: SystemMailUpdateInput!): [SystemMailModel!]!

  """
  
        Updates an existing userConsent based on input.
        Returns updated userConsent.
      
  """
  updateUserConsent(id: String!, userConsent: UpdateUserConsentInput!): UserConsent!
}

type PaymentMethodRef {
  id: String!
  name: String!
}

enum PaymentPeriodicity {
  biannual
  monthly
  quarterly
  yearly
}

type PeriodicJobModel {
  createdAt: DateTime!
  date: DateTime!
  error: String
  executionTime: DateTime
  finishedWithError: DateTime
  id: String!
  modifiedAt: DateTime!
  successfullyFinished: DateTime
  tries: Float!
}

type Query {
  """
  
        Returns all active subscribers.
        Includes subscribers with a cancelled but not run out subscription.
      
  """
  activeSubscribers: [DashboardSubscription!]!

  """
  
        Returns a consent by id.
      
  """
  consent(id: String!): Consent!

  """
  
        Returns all consents.
      
  """
  consents(filter: ConsentFilter): [Consent!]!

  """
  
        Returns the expected revenue for the time period given.
        Excludes cancelled or manually set as paid invoices.
      
  """
  expectedRevenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!
  getSystemMails: [SystemMailModel!]!
  mailTemplates: [MailTemplateWithUrlAndStatusModel!]!

  """
  
        Returns all new deactivations in a given timeframe.
        This considers the time the deactivation was made, not when the subscription runs out.
      
  """
  newDeactivations(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """
  
        Returns all new subscribers in a given timeframe.
        Includes already deactivated ones.
      
  """
  newSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!
  paymentMethods: [PaymentMethodRef!]!

  """
  
        Returns 
      
  """
  periodicJobLog(skip: Float!, take: Float!): [PeriodicJobModel!]!
  provider: MailProviderModel!

  """
  
        Returns all renewing subscribers in a given timeframe.
      
  """
  renewingSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """
  
        Returns the revenue generated for the time period given.
        Only includes paid invoices that have not been manually paid.
      
  """
  revenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!
  subscriptionFlows(defaultFlowOnly: Boolean!, memberPlanId: String): [SubscriptionFlowModel!]!

  """
  
        Returns a single userConsent by id.
      
  """
  userConsent(id: String!): UserConsent!

  """
  
        Returns a list of userConsents. Possible to filter.
      
  """
  userConsents(filter: UserConsentFilter): [UserConsent!]!
  versionInformation: VersionInformation!
}

enum SubscriptionDeactivationReason {
  invoiceNotPaid
  none
  userSelfDeactivated
}

enum SubscriptionEvent {
  CUSTOM
  DEACTIVATION_BY_USER
  DEACTIVATION_UNPAID
  INVOICE_CREATION
  RENEWAL_FAILED
  RENEWAL_SUCCESS
  SUBSCRIBE
}

type SubscriptionFlowModel {
  autoRenewal: [Boolean!]!
  default: Boolean!
  id: String!
  intervals: [SubscriptionInterval!]!
  memberPlan: MemberPlanRef
  numberOfSubscriptions: Int!
  paymentMethods: [PaymentMethodRef!]!
  periodicities: [PaymentPeriodicity!]!
}

input SubscriptionFlowModelCreateInput {
  autoRenewal: [Boolean!]!
  memberPlanId: String!
  paymentMethodIds: [String!]!
  periodicities: [PaymentPeriodicity!]!
}

input SubscriptionFlowModelUpdateInput {
  autoRenewal: [Boolean!]!
  id: String!
  paymentMethodIds: [String!]!
  periodicities: [PaymentPeriodicity!]!
}

type SubscriptionInterval {
  daysAwayFromEnding: Int
  event: SubscriptionEvent!
  id: String!
  mailTemplate: MailTemplateRef
}

input SubscriptionIntervalCreateInput {
  daysAwayFromEnding: Int
  event: SubscriptionEvent!
  mailTemplateId: String
  subscriptionFlowId: String!
}

input SubscriptionIntervalDeleteInput {
  id: String!
}

input SubscriptionIntervalUpdateInput {
  daysAwayFromEnding: Int
  id: String!
  mailTemplateId: String
}

type SystemMailModel {
  event: UserEvent!
  mailTemplate: MailTemplateRef
}

input SystemMailTestInput {
  event: UserEvent!
}

input SystemMailUpdateInput {
  event: UserEvent!
  mailTemplateId: String!
}

input UpdateUserConsentInput {
  value: Boolean!
}

type User {
  active: Boolean!
  createdAt: DateTime!
  email: String!
  emailVerifiedAt: DateTime
  firstName: String
  id: String!
  lastLogin: DateTime
  modifiedAt: DateTime!
  name: String!
  password: String!
  preferredName: String
  roleIDs: [String!]!
  userImageID: String
}

type UserConsent {
  consent: Consent!
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  user: User!
  value: Boolean!
}

input UserConsentFilter {
  name: String
  slug: String
  value: Boolean
}

input UserConsentInput {
  consentId: String!
  userId: String!
  value: Boolean!
}

enum UserEvent {
  ACCOUNT_CREATION
  LOGIN_LINK
  PASSWORD_RESET
  TEST_MAIL
}

type VersionInformation {
  version: String!
}
