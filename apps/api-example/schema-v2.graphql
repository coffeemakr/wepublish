# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AdditionalIntervalCreateInput {
  daysAwayFromEnding: Int!
  mailTemplate: MailTemplateRefInput!
  subscriptionFlowId: Int!
}

input AdditionalIntervalDeleteInput {
  additionalIntervalId: Int!
  subscriptionFlowId: Int!
}

type DashboardInvoice {
  amount: Int!
  dueAt: DateTime!
  memberPlan: String
  paidAt: DateTime
}

type DashboardSubscription {
  endsAt: DateTime
  memberPlan: String!
  monthlyAmount: Int!
  paymentPeriodicity: PaymentPeriodicity!
  reasonForDeactivation: SubscriptionDeactivationReason
  renewsAt: DateTime
  startsAt: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type MailProviderModel {
  name: String!
}

type MailTemplateRef {
  id: Int!
  name: String!
}

input MailTemplateRefInput {
  id: Int!
}

type MailTemplateWithUrlModel {
  description: String
  externalMailTemplateId: String!
  id: Int!
  name: String!
  remoteMissing: Boolean!
  url: String!
}

type MemberPlanRef {
  id: String!
  name: String!
}

input MemberPlanRefInput {
  id: String!
}

type Mutation {
  addAdditionalIntervalToSubscriptionFlow(additionalInterval: AdditionalIntervalCreateInput!): [SubscriptionFlowModel!]!
  createSubscriptionFlow(subscriptionFlow: SubscriptionFlowModelCreateInput!): [SubscriptionFlowModel!]!
  createSubscriptionInterval(subscriptionInterval: SubscriptionIntervalCreateInput!): [SubscriptionFlowModel!]!
  deleteSubscriptionFlow(subscriptionFlowId: Int!): [SubscriptionFlowModel!]!
  removeAdditionalIntervalToSubscriptionFlow(additionalInterval: AdditionalIntervalDeleteInput!): [SubscriptionFlowModel!]!
  syncTemplates: Boolean!
  updateSubscriptionFlow(subscriptionFlow: SubscriptionFlowModelUpdateInput!): [SubscriptionFlowModel!]!
  updateSubscriptionInterval(subscriptionInterval: SubscriptionIntervalUpdateInput!): [SubscriptionFlowModel!]!
}

type PaymentMethodRef {
  id: String!
  name: String!
}

input PaymentMethodRefInput {
  id: String!
}

enum PaymentPeriodicity {
  biannual
  monthly
  quarterly
  yearly
}

type Query {
  SubscriptionFlows(defaultFlowOnly: Boolean!): [SubscriptionFlowModel!]!

  """
  
        Returns all active subscribers.
        Includes subscribers with a cancelled but not run out subscription.
      
  """
  activeSubscribers: [DashboardSubscription!]!

  """
  
        Returns the expected revenue for the time period given.
        Excludes cancelled or manually set as paid invoices.
      
  """
  expectedRevenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!
  mailTemplates: [MailTemplateWithUrlModel!]!

  """
  
        Returns all new deactivations in a given timeframe.
        This considers the time the deactivation was made, not when the subscription runs out.
      
  """
  newDeactivations(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """
  
        Returns all new subscribers in a given timeframe.
        Includes already deactivated ones.
      
  """
  newSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!
  provider: MailProviderModel!

  """
  
        Returns all renewing subscribers in a given timeframe.
      
  """
  renewingSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """
  
        Returns the revenue generated for the time period given.
        Only includes paid invoices that have not been manually paid.
      
  """
  revenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!
  versionInformation: VersionInformation!
}

enum SubscriptionDeactivationReason {
  invoiceNotPaid
  none
  userSelfDeactivated
}

type SubscriptionFlowModel {
  additionalIntervals: [SubscriptionInterval!]!
  autoRenewal: [Boolean!]!
  deactivationByUserMailTemplate: MailTemplateRef
  deactivationUnpaidMailTemplate: SubscriptionInterval
  default: Boolean!
  id: Int!
  invoiceCreationMailTemplate: SubscriptionInterval
  memberPlan: MemberPlanRef!
  paymentMethods: [PaymentMethodRef!]!
  periodicities: [PaymentPeriodicity!]!
  reactivationMailTemplate: MailTemplateRef
  renewalFailedMailTemplate: MailTemplateRef
  renewalSuccessMailTemplate: MailTemplateRef
  subscribeMailTemplate: MailTemplateRef
}

input SubscriptionFlowModelCreateInput {
  additionalIntervals: [SubscriptionIntervalCreateInput!]!
  autoRenewal: [Boolean!]!
  deactivationByUserMailTemplate: MailTemplateRefInput
  deactivationUnpaidMailTemplate: SubscriptionIntervalCreateInput
  invoiceCreationMailTemplate: SubscriptionIntervalCreateInput
  memberPlan: MemberPlanRefInput!
  paymentMethods: [PaymentMethodRefInput!]!
  periodicities: [PaymentPeriodicity!]!
  reactivationMailTemplate: MailTemplateRefInput
  renewalFailedMailTemplate: MailTemplateRefInput
  renewalSuccessMailTemplate: MailTemplateRefInput
  subscribeMailTemplate: MailTemplateRefInput
}

input SubscriptionFlowModelUpdateInput {
  autoRenewal: [Boolean!]!
  deactivationByUserMailTemplate: MailTemplateRefInput
  deactivationUnpaidIntervalId: Float
  id: Int!
  invoiceCreationIntervalId: Float
  paymentMethods: [PaymentMethodRefInput!]!
  periodicities: [PaymentPeriodicity!]!
  reactivationMailTemplate: MailTemplateRefInput
  renewalFailedMailTemplate: MailTemplateRefInput
  renewalSuccessMailTemplate: MailTemplateRefInput
  subscribeMailTemplate: MailTemplateRefInput
}

type SubscriptionInterval {
  daysAwayFromEnding: Int!
  id: Int!
  mailTemplate: MailTemplateRef!
}

input SubscriptionIntervalCreateInput {
  daysAwayFromEnding: Int!
  mailTemplate: MailTemplateRefInput!
}

input SubscriptionIntervalUpdateInput {
  daysAwayFromEnding: Int
  id: Int
  mailTemplate: MailTemplateRefInput
}

type VersionInformation {
  version: String!
}
