// THIS FILE IS AUTOGENERATED
import {Node} from 'slate'
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: string;
};

export type DashboardInvoice = {
  __typename?: 'DashboardInvoice';
  amount: Scalars['Int'];
  dueAt: Scalars['DateTime'];
  memberPlan?: Maybe<Scalars['String']>;
  paidAt?: Maybe<Scalars['DateTime']>;
};

export type DashboardSubscription = {
  __typename?: 'DashboardSubscription';
  deactivationDate?: Maybe<Scalars['DateTime']>;
  endsAt?: Maybe<Scalars['DateTime']>;
  memberPlan: Scalars['String'];
  monthlyAmount: Scalars['Int'];
  paymentPeriodicity: PaymentPeriodicity;
  reasonForDeactivation?: Maybe<SubscriptionDeactivationReason>;
  renewsAt?: Maybe<Scalars['DateTime']>;
  startsAt: Scalars['DateTime'];
};

export type MailProviderModel = {
  __typename?: 'MailProviderModel';
  name: Scalars['String'];
};

export type MailTemplateRef = {
  __typename?: 'MailTemplateRef';
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type MailTemplateWithUrlAndStatusModel = {
  __typename?: 'MailTemplateWithUrlAndStatusModel';
  description?: Maybe<Scalars['String']>;
  externalMailTemplateId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  remoteMissing: Scalars['Boolean'];
  status: Scalars['String'];
  url: Scalars['String'];
};

export type MemberPlanRef = {
  __typename?: 'MemberPlanRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  createSubscriptionFlow: Array<SubscriptionFlowModel>;
  createSubscriptionInterval: Array<SubscriptionFlowModel>;
  deleteSubscriptionFlow: Array<SubscriptionFlowModel>;
  deleteSubscriptionInterval: Array<SubscriptionFlowModel>;
  syncTemplates: Scalars['Boolean'];
  updateSubscriptionFlow: Array<SubscriptionFlowModel>;
  updateSubscriptionInterval: Array<SubscriptionFlowModel>;
  updateSubscriptionIntervals: Array<SubscriptionFlowModel>;
};


export type MutationCreateSubscriptionFlowArgs = {
  subscriptionFlow: SubscriptionFlowModelCreateInput;
};


export type MutationCreateSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalCreateInput;
};


export type MutationDeleteSubscriptionFlowArgs = {
  subscriptionFlowId: Scalars['Int'];
};


export type MutationDeleteSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalDeleteInput;
};


export type MutationUpdateSubscriptionFlowArgs = {
  subscriptionFlow: SubscriptionFlowModelUpdateInput;
};


export type MutationUpdateSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalUpdateInput;
};


export type MutationUpdateSubscriptionIntervalsArgs = {
  subscriptionIntervals: Array<SubscriptionIntervalUpdateInput>;
};

export type PaymentMethodRef = {
  __typename?: 'PaymentMethodRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export enum PaymentPeriodicity {
  Biannual = 'biannual',
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Yearly = 'yearly'
}

export type Query = {
  __typename?: 'Query';
  /**
   * Returns all active subscribers.
   * Includes subscribers with a cancelled but not run out subscription.
   */
  activeSubscribers: Array<DashboardSubscription>;
  /**
   * Returns the expected revenue for the time period given.
   * Excludes cancelled or manually set as paid invoices.
   */
  expectedRevenue: Array<DashboardInvoice>;
  mailTemplates: Array<MailTemplateWithUrlAndStatusModel>;
  /**
   * Returns all new deactivations in a given timeframe.
   * This considers the time the deactivation was made, not when the subscription runs out.
   */
  newDeactivations: Array<DashboardSubscription>;
  /**
   * Returns all new subscribers in a given timeframe.
   * Includes already deactivated ones.
   */
  newSubscribers: Array<DashboardSubscription>;
  paymentMethods: Array<PaymentMethodRef>;
  provider: MailProviderModel;
  /** Returns all renewing subscribers in a given timeframe. */
  renewingSubscribers: Array<DashboardSubscription>;
  /**
   * Returns the revenue generated for the time period given.
   * Only includes paid invoices that have not been manually paid.
   */
  revenue: Array<DashboardInvoice>;
  subscriptionFlows: Array<SubscriptionFlowModel>;
  versionInformation: VersionInformation;
};


export type QueryExpectedRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryNewDeactivationsArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryNewSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryRenewingSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QuerySubscriptionFlowsArgs = {
  defaultFlowOnly: Scalars['Boolean'];
  memberPlanId?: InputMaybe<Scalars['String']>;
};

export enum SubscriptionDeactivationReason {
  InvoiceNotPaid = 'invoiceNotPaid',
  None = 'none',
  UserSelfDeactivated = 'userSelfDeactivated'
}

export enum SubscriptionEvent {
  Custom = 'CUSTOM',
  DeactivationByUser = 'DEACTIVATION_BY_USER',
  DeactivationUnpaid = 'DEACTIVATION_UNPAID',
  InvoiceCreation = 'INVOICE_CREATION',
  Reactivation = 'REACTIVATION',
  RenewalFailed = 'RENEWAL_FAILED',
  RenewalSuccess = 'RENEWAL_SUCCESS',
  Subscribe = 'SUBSCRIBE'
}

export type SubscriptionFlowModel = {
  __typename?: 'SubscriptionFlowModel';
  autoRenewal: Array<Scalars['Boolean']>;
  default: Scalars['Boolean'];
  id: Scalars['Int'];
  intervals: Array<SubscriptionInterval>;
  memberPlan?: Maybe<MemberPlanRef>;
  numberOfSubscriptions: Scalars['Int'];
  paymentMethods: Array<PaymentMethodRef>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionFlowModelCreateInput = {
  autoRenewal: Array<Scalars['Boolean']>;
  memberPlanId: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionFlowModelUpdateInput = {
  autoRenewal: Array<Scalars['Boolean']>;
  id: Scalars['Int'];
  paymentMethodIds: Array<Scalars['String']>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionInterval = {
  __typename?: 'SubscriptionInterval';
  daysAwayFromEnding?: Maybe<Scalars['Int']>;
  event: SubscriptionEvent;
  id: Scalars['Int'];
  mailTemplate?: Maybe<MailTemplateRef>;
};

export type SubscriptionIntervalCreateInput = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  event: SubscriptionEvent;
  mailTemplateId?: InputMaybe<Scalars['Int']>;
  subscriptionFlowId: Scalars['Int'];
};

export type SubscriptionIntervalDeleteInput = {
  id: Scalars['Int'];
};

export type SubscriptionIntervalUpdateInput = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  id: Scalars['Int'];
  mailTemplateId?: InputMaybe<Scalars['Int']>;
};

export type VersionInformation = {
  __typename?: 'VersionInformation';
  version: Scalars['String'];
};

export type VersionInformationQueryVariables = Exact<{ [key: string]: never; }>;


export type VersionInformationQuery = { __typename?: 'Query', versionInformation: { __typename?: 'VersionInformation', version: string } };


export const VersionInformationDocument = gql`
    query VersionInformation {
  versionInformation {
    version
  }
}
    `;

/**
 * __useVersionInformationQuery__
 *
 * To run a query within a React component, call `useVersionInformationQuery` and pass it any options that fit your needs.
 * When your component renders, `useVersionInformationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVersionInformationQuery({
 *   variables: {
 *   },
 * });
 */
export function useVersionInformationQuery(baseOptions?: Apollo.QueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
      }
export function useVersionInformationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
        }
export type VersionInformationQueryHookResult = ReturnType<typeof useVersionInformationQuery>;
export type VersionInformationLazyQueryHookResult = ReturnType<typeof useVersionInformationLazyQuery>;
export type VersionInformationQueryResult = Apollo.QueryResult<VersionInformationQuery, VersionInformationQueryVariables>;